#=============================================================================
# Copyright (C) 2013 Gregor Larson <gregor.larson@gmail.com>
#
# This file is part of SecRepo
#
# SecRepo is free software; you can redistribute it and/or modify it under the
# terms of the GNU Lesser General Public License as published by the Free
# Software Foundation; either version 2.1 of the License, or (at your option)
# any later version.
#
# SecRepo is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with SecRepo; if not, see:
#     http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
#=============================================================================
'''Secrepo main implementation module.

@author: Gregor Larson <gregor.larson@gmail.com>
@license: LGPLv2.1
@version: 0.1
'''

from __future__ import print_function
import sys,os,subprocess,shlex,hashlib,threading,tempfile,zlib,gzip,shutil
import binascii,struct
from getpass import getpass
from os.path import expanduser,isdir,isfile
from subprocess import PIPE,CalledProcessError,Popen
from base64 import b32encode,b64encode,b64decode
try:
    from Cryptodome.Cipher import AES
    from Cryptodome.Hash import SHA256
    from Cryptodome.Protocol.KDF import PBKDF2
except:
    from Crypto.Cipher import AES
    from Crypto.Hash import SHA256
    from Crypto.Protocol.KDF import PBKDF2

#
# Global values and Utility Flags
#
is_bsd=False
if sys.platform[:3] == 'win':
   import msvcrt
   import nt
   # Because os.environ maps to upper-case we sometimes
   # need to use nt.environ instead.
   os_environ = nt.environ
   is_windoz = True
   # For windows, we need to indicate O_BINARY to read and
   # write files without any text-mapping.
   os_create=os.O_WRONLY|os.O_CREAT|os.O_BINARY
   os_read=os.O_RDONLY|os.O_BINARY
   os_overwrite=os.O_WRONLY|os.O_BINARY		# overwrite a file in-place
else:
   os_environ = os.environ
   is_windoz = False
   os_read=os.O_RDONLY
   os_create=os.O_WRONLY|os.O_CREAT
   os_overwrite=os.O_WRONLY			# overwrite a file in-place
   if sys.platform.find('bsd') >= 0:
      is_bsd = True

# More output
flags_verbose=False
# Less output
flags_quiet=False

# secrepo log mode
sr_log_mode=False
# secrepo reset mode
sr_reset_mode=False

# Config file name
# Used as {git-dir}/{srconfig_file} for local config.
# Used as {HOME}/.{srconfig_file} for global config.
# Note that unit-tests change this to 'srtesting', so
# don't use it during module initialization.
#
srconfig_file='srconfig'

# Control location of temporary file.
tmpfs=None

# Environment variable SECREPO_DEBUG is used to enable
# debug output.
debug_level=0

# Size of header for encrypted files.
header_size=64

# Current default version for encryption
default_version=1

# May be modified for unit-testing
default_editor=['vim']

# Scope for config changes or indication of where decryption key was found
SR_LOCAL=1
SR_GLOBAL=2
SR_ENVIRON=3

#
# Exceptions
#
class SrException(UserWarning):
  '''Exception generated by the secrepo module.
  First arg is some text.
  Second arg is underlying exception, if any.'''
  # TODO: change to inherit from recommended
  # http://docs.python.org/2/library/exceptions.html#exceptions.Exception
  def report(self,note=''):
      'report exception to user, with optional note appended.'
      if debug_level:
         exc_type, exc_value, exc_traceback = sys.exc_info()
         traceback.print_tb(exc_traceback, limit=3, file=sys.stderr)

      if len(self.args) > 1:
          if self.args[1]:
             note=note+"\n   exception:"+self.args[1].__str__()

      warning(" ".join([t for t in [self._report(),note] if t]))

  def _report(self):
      'should be overridden below'
      return 'secrepo failure '+self.args[0]

class EncryptDecryptFail(SrException):
  '''Failure of encryption or decription not due to missing key.
  Second arg is underlying exception, if any.'''
  pass

class EncryptFail(EncryptDecryptFail):
  '''Exception during encryption not due to missing key.
  Second arg is underlying exception, if any.'''
  def _report(self):
     return "Encryption failed "+self.args[0]

class DecryptFail(EncryptDecryptFail):
  '''Exception during decryption not due to missing key.
  Second arg is underlying exception, if any.'''
  def _report(self):
     return "Decryption failed "+self.args[0]

class NoKeyAvailable(SrException):
  '''First arg is key name being sought or 'unknown' if keyname is not known.
  Second arg is underlying exception, if any.
  Third arg is key fingerprint, if any.'''
  def _report(self):
      if len(self.args) > 2:
         return "No key (%s) fp: '%s' available." % (self.args[0],self.args[2])
      return "No key (%s) available." % self.args[0]

class NoDefaultEncryptionKey(NoKeyAvailable):
  '''Key name is not known so first arg is 'unknown'.
  Second arg is underlying exception, if any.'''
  def _report(self):
      return "Default key for encryption not found."

class GunzipFail(DecryptFail):
  '''Decryption failed because gunzip of the decrypted data failed.
  Second arg is underlying exception, if any.'''
  def _report(self):
      return self.args[0]

class InvalidHeader(DecryptFail):
  '''Exception while handling header. First arg is description.
  Second arg is underlying exception, if any.'''
  def _report(self):
      return("Header error: "+self.args[0])

class GitFail(SrException):
   'A git command did not succeed. First arg is description or stderr from git.'
   def _report(self):
      return("git failed: "+self.args[0])
  
class GitNoRepo(GitFail):
   'An attempt to use a git repo, but there is no current repo.'
   def _report(self):
      return("No current git repo. To use global scope, specify --global or -g")

# Invoke from bottom of module
def module_main():
    '''Module initialization'''
    d=os.environ.get('SECREPO_DEBUG')
    if d:
       global debug_level
       debug_level=int(d)

    global flags_verbose
    if os.environ.get('SECREPO_VERBOSE'):
       flags_verbose=True

    global flags_quiet
    if os.environ.get('SECREPO_QUIET'):
       flags_quiet=True

    # Allow redirection of stderr by unit-tests.
    global stderr
    stderr=sys.stderr
    global user_stdin
    # user_stdin is used for interactive user input
    user_stdin=sys.stdin

    if 'SR_LOGMODE' in os.environ:
        # see git-secrepo log -h
        global sr_log_mode
        sr_log_mode=True

    if 'SR_RESETMODE' in os.environ:
        global sr_reset_mode
        sr_reset_mode=True

    # Portability
    home=os.environ["HOME"]
    global tmpfs
    if sys.platform[:5] == 'linux':
       # Prefer RAM backed files because these are slightly faster
       # and slighty more secure in that they are harder to recover
       # after a reset.
       # Prefer {HOME} over /tmp because {HOME} may be encrypted and
       # more secure.
       if os.path.isdir('/run/shm'):
          tmpfs='/run/shm'
       elif os.path.isdir('/dev/shm'):
          tmpfs='/dev/shm'
       elif os.path.isdir(home+'/tmp'):
          tmpfs=home+'/tmp'
       else:
          tmpfs=home
    elif sys.platform == 'cygwin':
       if os.path.isdir(home+'/tmp'):
          tmpfs=home+'/tmp'
       else:
          # Default to home directory
          # We don't use /tmp because HOME might be more secure (ntfs encryption).
          tmpfs=home
    elif is_windoz:
       # Windows
       global default_editor
       # For windows subprocess, the target must be a real windoz .exe found on
       # path or fully specified. A shell script will not work.
       # In secrepo_test, to use a editor script for windows, default_editor
       # is changed to ['sh','fake editor script']
       #
       default_editor=[
          'C:\\Program Files (x86)\\Git\\share\\vim\\vim73\\vim.exe']
       if not os.path.isfile(default_editor[0]):
          default_editor=['notepad']

       tmpfs=home

    # TODO: add bsd 

def debug_log(level,*s):
  'Debug logs are always sent to sys.stderr'
  if debug_level >= level:
     print(s,file=sys.stderr)

def warning(*s,**k):
  'Warning messages go to stderr by default but may be redirected'
  out="".join([x.__str__() for x in s])
  print(out,file=stderr)
  e=k.get('exception')
  if e: print("   Exception:",e,file=stderr)

def protect_file(filename):
  '''Set permissions on file to allow only user to access.'''

  if is_windoz:
     # TODO: figure out what security measures make sense for windows.
     return

  try:
    os.chmod(filename,0o600)
  except OSError as e:
    warning("Error protecting file '%s'" % filename,exception=e)

def generic_args(description=None,epilog=None):
    '''add cmdline args applicable to all commands.'''
    import argparse
    parser = argparse.ArgumentParser(description=description,epilog=epilog)
    #parser.add_argument("--debug", type=int, help="set the debug level")
    parser.add_argument("--verbose","-v",action="store_true",
       help="enable verbose output")
    parser.add_argument("--quiet","-q",action="store_true",
       help="reduce output")
    return parser

def process_generic_args(args,aparser):
    '''process cmdline args applicable to all commands.'''

    pargs = aparser.parse_args(args)

    global flags_verbose
    if pargs.verbose: flags_verbose=True

    global flags_quiet
    if pargs.quiet: flags_quiet=True
    elif os.environ.get('GIT_COMMIT'):
       # If GIT_COMMIT is set, we assume we are in a tree-filter where
       # we probably don't want huge amounts of output.
       if (debug_level==0) and not flags_verbose:
          flags_quiet=True

    #global debug_level
    #if pargs.debug: debug_level=pargs.debug

    return pargs

def sredit_cmd(args):
    '''sredit command'''
    parser=generic_args()
    parser.add_argument("file",type=str)
    cmdargs=process_generic_args(args,parser)
    if debug_level: debug_log(2,'sredit_cmd',cmdargs)
    if file_is_encrypted(cmdargs.file):
       try:
          sredit_encrypted(cmdargs.file)
       except NoKeyAvailable as e:
          e.report()
          return 2
       except SrException as e:
          e.report()
          return 1

    else:
       edit_existing_file(cmdargs.file)

    return 0	# exit 0

def srdiff_cmd(args,check_only):
    '''sr_diff command.
    This takes an encrypted temp-file and outputs decrypted data.
    If decryption is not possible (due to missing keys), then a
    single line of output is produced indicating the header info.
    This function should return 0 to git to indicate that the filter
    worked.'''
    parser=generic_args()
    parser.add_argument("file",type=str)
    cmdargs=process_generic_args(args,parser)
    # If the file was not smudged this could be because
    # the smudge filter was not activated, or, the attributes
    # were not set or perhaps a key was not available.
    #
    fn=os.open(cmdargs.file,os_read)

    # In the case were there are binary files (images etc) in the
    # repo, this filter can cause unwanted junk in the git diff
    # or git log -p
    # To avoid this, we would have to inspect the decrypted output
    # of the smudge filter and substitute a summary line instead.
    #
    # As far as I know, there is no way to 'chain' multiple filters.

    out_file=sys.stdout.fileno()
    if is_windoz:
       # For windows, std stdout to binary.
       msvcrt.setmode(out_file, os.O_BINARY)

    if debug_level:
       debug_log(2,'srdiff_cmd %s -> %d co:%s' % (cmdargs.file, out_file, check_only), cmdargs)
    try:
       rc = smudge_filter(fn,out_file,check_only)
       if check_only:
          if not rc:
             return 1
       return 0		# exit 0
    except SrException as e:
       if debug_level:
          debug_log(2,f"srdiff e: {e}")

       # Pass this exception because we will try and output
       # some substitute below. TODO: debug output?
       pass
    finally:
       os.close(fn)

    if check_only: return 1 # not sr-encrypted

    # If we cannot decrypt the file, we revert to a
    # semi-symbolic mode: version, keyname, finger, size
    # The reason we don't do this in the smudge_filter is that
    # we don't want to hide missing key problems from the user.
    # If the user doesn't want to use smudge filters, they can
    # be deactivated in the .git/config and then this filter will
    # be used for git log -p and git diff but not for updating the
    # working tree.
    fn=os.open(cmdargs.file,os_read)
    header = Header(fn)
    size=os.fstat(fn).st_size - header_size
    os.close(fn)

    # Report unavailable key is log_mode format.
    sr_log_enc(1,header.keyname,header.keyfinger,size,None)
    return 0	# exit 0

def secrepo_cmd(args):
   '''git-secrepo command.'''

   parser=generic_args(
      description='Manage secrepo git configuration and keys.',
      epilog='''To avoid exposing the key in your command history
      or process list, use the name or  key finger-print to
      specify the key. Keys and names are case sensitive and should not
      contain spaces, tabs, quotes : or ; but may contain other
      punctuation chars.
      (todo) - add reference to github html manpage when available''')

   sp = parser.add_subparsers(dest='srcmd',
       help='for addition help use {command} -h')

   add_p = sp.add_parser('add',
      help='''Add an exiting key to this repo.
      A name for the key must be provided.
      The key value will be prompted for. This is the option
      to use in order to copy/paste a key previously generated.
      The enterred key should have sufficient entropy for encryption.
      Please be aware that keys are stored in config files
      and can be accessed by others. Do not use your login
      password or other encryption keys for secrepo.''')
   add_p.add_argument('--raw','-r',action='store_true',
      help='''Store the enterred key as-is, do not normalize with
      a key derivation function. Note that this option may be removed
      in the future.''')
   add_p.add_argument('key_name',
      help='the name that will be assigned to the new key')

   config_p = sp.add_parser('config',
      help='Configure the smudge and diff filters in git repo.')

   config_p.add_argument('--activate','-a',action='store_true',
      help='''Configure for transparent encryption. This is the
      `normal` configuration for an encrypted repo with a decrypted
      workspace.''')

   config_p.add_argument('--decrypt','-d',action='store_true',
      help='''Configure for decryption only. Files will not be encrypted
      when added or committed. This is a special-purpose configuration
      and not for a normal work-flow.''')

   config_p.add_argument('--encrypt','-e',action='store_true',
      help='''Configure for encryption only. Files will not be decrypted
      when checked out into workspace. This is a special-purpose configuration
      and not for a normal work-flow.''')

   config_p.add_argument('--nosmudge','-n',action='store_true',
      help='''Remove the smudge/clean filters and add only the
      diff config to git repo. This is useful when using a git-repo
      with encrypted content but the keys will not be made available
      in this instance.''')

   config_p.add_argument('--unconfig','-u',action='store_true',
      help='''Remove the smudge and diff config from git repo.
      .gitattributes are not affected.''')

   decrypt_p = sp.add_parser('decrypt',
      help='''Decrypt file(s) in-place. Reads filenames from
      stdin and decrypts them in-place (if not already decrypted).
      Can be used in pipeline as git ls-files | git-secrepo decrypt''')

   decrypt_p.add_argument('-infile','-f',dest='filename',
      help='''Specify a single file to be decrypted rather than a list
      from stdin.''')

   encrypt_p = sp.add_parser('encrypt',
      help='''Does not actually encrypt files, but rather checks for an
      encryption header and touches (updates mtime) on non-encrypted files.
      For use in tree-filers with git-ls-files. Reads filenames from stdin''')

   default_p = sp.add_parser('default',
      help='''Change the default key for encryption.
      The key or name must be provided.''')
   default_p.add_argument('key_selector',
      help='''Provide a name or key finger-print to select the default key
      for encryption''')
      
   del_p = sp.add_parser('del',
      help='''Delete one or more keys with provided name or key value.
      The keys to be deleted will be displayed and there is a prompt
      for confirmation in order to avoid accidental loss.''')
   del_p.add_argument('key_selector',
      help='provide a key name or finger-print')

   #parser.add_argument('--echo','-e',action='store_true',
   #	help='Echo chars to terminal when entering key.')

   delall_p = sp.add_parser('delall',
      help='''Delete all the keys in the local git repo. The set
      of keys is displayed with a confirmation prompt in order to
      avoid accidental loss.''')

   export_p = sp.add_parser('export',
      help='''Export keys to to stdout for use with import
      Add -g to include global keys as well.''')

   parser.add_argument('--global','-g',dest='glob',action='store_true',
      help='''Affect the global key-store in ~/.secrepo instead of the
      local git config. Works for add, new, del, delall, import, export,
      default, name''')

   parser.add_argument('--env','-e',action='store_true',
      help='''Affect environment variables instead of configuration on disk.
      See also the sredit command if you need to edit only a single file.
      Be aware that on some systems, environment variables are not completely
      private and may be viewed by administrative users or even regular users.
      Note that the environment variables changes are sent to stdout in
      bourne/posix shell syntax so the eval statement can be used. For
      example: eval `git secrepo -e ....`''')

   import_p = sp.add_parser('import',
      help='''Import keys from export. Input must come from
      stdin (pasted into terminal or directed from file).
      Note that existing keys will not renamed.
      Use -g to import to global key-store.''')
      
   # ? no aliases in Python 2.7?
   listkeys_p = sp.add_parser('keys',			# aliases=['listkeys','list','l','lk'],
      help='List the available keys.')

   log_p = sp.add_parser('log',
      help='Do a git log -p in a mode that shows encryption meta-data.')

   log_p.add_argument('-p',dest='log_parms',default=None,
      help='Additional parameters for git log -p {parms} split using shlex')

   new_p = sp.add_parser('new',
      help='''Generate a new key. A name for the new key must be provided.
      Creation of multiple keys with the same name is allowed,
      however, there may be a confirmation prompt. The new key generated
      is displayed so you can copy it to separate storage.
      The key name is not significant. If you are using only one key
      just name it: default''')
   new_p.add_argument('key_name')

   name_p = sp.add_parser('name',
      help='''Provide a new name for a key. The first arg is
      the key (by name or finger-print). The second arg is the
      new name.''')
   name_p.add_argument('key_selector',
      help='indicate an existing key by name or finger-print')
   name_p.add_argument('key_name',
      help='provide the new name for the key')

   reset_p = sp.add_parser('reset',
      help='''Use git reset and git status in a special mode to get the
      index to recognize encrypted files in the working tree. This will
      not actually decrypt the files in the working tree, but it may show
      you where they are. It may also be necessary to use secrepo decrypt
      to decrypt the files in-place if you have been using sredit on the
      encrypted working-tree files.''')

   wipe_p = sp.add_parser('wipe',
      help='''Wipe temporary keys in environment variables.
      Similar to -e delall.
      Works with bourne/bash/posix style shells.
      Usage: eval `git-secrepo wipe`''')

   try:
      if not args:
         sr_status()
         return

      cmdargs=process_generic_args(args,parser)

      glob=cmdargs.glob		# depricate
      if cmdargs.glob:
         if cmdargs.env:
            raise SrException("Usage error: global and env cannot be used together.")
         sr_scope = SR_GLOBAL
      else:
         if cmdargs.env:
            sr_scope = SR_ENVIRON
         else:
            sr_scope = SR_LOCAL

      srcmd=cmdargs.srcmd

      debug_log(2,cmdargs)
      if	srcmd=='add':		sr_add(cmdargs.key_name,sr_scope,cmdargs.raw)
      elif	srcmd=='decrypt':	sr_decrypt(cmdargs.filename)
      elif	srcmd=='default':	sr_default(cmdargs.key_selector,sr_scope)
      elif	srcmd=='del':		sr_del(cmdargs.key_selector,glob)
      elif	srcmd=='delall':	sr_delall(glob)
      elif	srcmd=='encrypt':	sr_encrypt()
      elif	srcmd=='export':	sr_export(sr_scope)
      elif	srcmd=='import':	sr_import(sr_scope)
      elif	srcmd=='keys':		sr_listkeys()
      elif	srcmd=='log':		sr_log(cmdargs.log_parms)
      elif	srcmd=='name':
                sr_setname(cmdargs.key_selector,cmdargs.key_name,sr_scope)
      elif	srcmd=='new':		sr_new(cmdargs.key_name,glob)
      elif	srcmd=='config':
         if	cmdargs.nosmudge:	sr_nosmudge()
         elif	cmdargs.unconfig:	sr_unconfig()
         elif	cmdargs.decrypt:	sr_config_decrypt()
         elif	cmdargs.encrypt:	sr_config_encrypt()
         elif	cmdargs.activate:	sr_config_activate()
         else:	sr_config()
      elif	srcmd=='reset':		sr_reset()
      elif	srcmd=='wipe':		sr_wipe()
      else:	sr_status()
   except SrException as e:
      e.report()
      return 1		# exit 1

   return 0	# exit 0

def sr_status():
   '''Output secrepo status.'''

   # TODO: output global status here.

   try:
      local_status()
   except GitFail:
      print("Not in working tree.")

   # TODO: output environment status

def config_status(gr):
   '''Output configuration status.
   Used when reporting current status and after a config change.'''

   warning("Current git workspace configuration:")
   v = gr.getconfig('filter.private.clean')
   if v == 'sr_clean':
      warning("   Encryption enabled, filter.private.clean "+v)
   else:
      warning("   Encryption disabled.")

   v = gr.getconfig('filter.private.smudge')
   if v == 'sr_smudge':
      warning("   Decryption enabled, filter.private.smudge "+v)
   else:
      warning("   Decryption disabled.")

   v = gr.getconfig('diff.private.textconv')
   if v == 'sr_diff':
      warning("   Temporary decryption enabled, diff.private.textconv "+v)
   else:
      warning("   Temporary decryption disabled.")

   warning("   Note that .gitattributes controls which files are affected.")
   warning("   To see config options use: git secrepo config -h")

def local_status():
   '''Output local status or raise exception if not available.'''
   gr=git()
   keys=gr.get_keys()
   
   config_status(gr)

   warning("\nLocal keys:")
   dkey=gr.get_encryption_key()
   if keys:
      if dkey:
         warning("   %d key(s) configured on local repo." % len(keys))
         warning("   The default key for encryption is '%s' name: '%s'"
            % (create_keyfinger(dkey),keys[dkey]))
      else:
         warning("   %d key(s) configured on local repo (no default)." % len(keys))
         warning("   A default key should be selected. See git secrepo default")

   else:
      warning("   No keys configured on local repo.")
      warning("   To enable encryption on this repo, import keys or generate a new")
      warning("   key using: git secrepo new default")

   global_status()

   warning("\nTo list keys, use: git secrepo keys")
   if not dkey and not gconf().get_encryption_key():
      warning("   There is no default key for encryption.")
      warning("   Files will be added to git unencrypted.")

def global_status():
   gc=gconf()
   gkeys=gc.get_keys()
   gck=gc.get_encryption_key()

   warning("\nGlobal keys:")
   if gkeys:
      if gck:
         warning("   %d key(s) configured globally." % len(gkeys))
         warning("   The global default key for encryption is '%s' name: '%s'"
            % (create_keyfinger(gck),gkeys[gck]))
      else:
         warning("   %d key(s) configured globally (no default)." % len(gkeys))
         warning("   Local repo key will be used for encryption if available")
   else:
      warning("   No keys configured globally.")

def sr_add(name,scope,raw):
   '''Allow input of a new key.

   Note that sr_new and sr_add are very similar except that
   sr_new generates key and requires confirmation for duplicate
   name, where as, sr_add prompts for the key and warns about
   duplicate name.'''

   # can operate on global, environment or local config
   if scope == SR_GLOBAL:
      gr=gconf()
   elif scope == SR_ENVIRON:
      gr=srenv()
   else:
      gr=git()

   xkeys = gr.get_keys_named(name)
   if xkeys and not flags_quiet:
      warning("There are already %d key(s) in %s named %s" % (len(xkeys),gr.cfg_name,name))
      warning("It is recommended that you choose a different name.")

   if not flags_quiet:
      warning("Enter new key.")
      warning("Note that secrepo does not salt your pass-phrase when encrypting")
      warning("so if your key is something you can memorize, it may not have")
      warning("sufficient entropy to be secure.")
      if raw:
         warning("Raw keys may not contain spaces, tabs, commas or quotes")
      else:
         warning("A 256 bit base64 password will be stored as-is, other passwords will")
         warning("be normalized using a determanistic key derivation function so your")
         warning("plain-text password will not be visible in the config or environment.")

   user_key=user_stdin.readline().strip()
   if not user_key:
      warning("No input")
      return False
    
   if raw:
      if not valid_key(user_key):
         warning("Not a valid key. Failed.")
         return False

      newkey = user_key
   else:
      # If the user has entered a short key, I can use a key derivation
      # function to get a 256 bit key.
      newkey = normalize_key(user_key)
      if newkey != user_key and not flags_quiet:
         warning("Note that the password you entered was normalized. You can")
         warning("use the same password in the future to re-generatate this same")
         warning("key.")

   cname = gr.get_keyname(newkey)
   if cname:
      if cname == name:
         warning("Key already exists, no change.")
         return True
      else:
         warning("Key exists, changing name from '%s' to '%s'" % (cname,name))

   ec = gr.get_encryption_key()		# encryption key prior to this.
   gr.set_key(newkey,name)

   if not flags_quiet:
      warning("New key (%s) value:\n    '%s'" % (name,newkey))
      gr.new_default_note(ec)		# tell user if encryption key changed.
      warning("You should backup this key/password to avoid data loss.")

   gr.flush_config()

def normalize_key(ukey):
   '''Convert a user password to our standard 256 bit base64 key.'''
   try:
      if len(ukey) == 44:
         if len(ukey.decode('base64')) == 32:
            return ukey		# provided key is normal
   except binascii.Error:
      pass

   # Convert the user enterred password to a 256 bit key.
   return PBKDF2(password=ukey,salt='NoSalt',dkLen=32,count=1000).encode('base64').strip()

def sr_setname(kpat,newname,scope):
   'Set the name of a key, indicated by name or finger-print'
   if not valid_name(newname):
      warning("Invalid name.")
      return

   # can operate on global, environment or local config
   if scope == SR_GLOBAL:
      gr=gconf()
   elif scope == SR_ENVIRON:
      gr=srenv()
   else:
      gr=git()

   keys = gr.get_keys_matching(kpat)
   if len(keys) > 1:
      warning("ERROR: '%s' matches %d keys." % (kpat,len(keys)))
      sr_listkeys(keyname)
      return

   if not keys:
      warning("ERROR: no keys matched '%s'" % kpat)
      return

   # keys dict has only one item
   key=keys.items()[0][0]
   if keys[key] == newname:
      warning("Name already '%s', no change." % newname)

   gr.set_key(keys.items()[0][0],newname)
   gr.flush_config()

def sr_config():
   try:
      config_status(git())
   except GitFail:
      warning("The secrepo config command is only valid in a git working tree.")

def sr_config_activate():
   gr=git()
   gr.setconfig('filter.private.smudge','sr_smudge')
   gr.setconfig('filter.private.clean','sr_clean')
   # Should we do gr.setconfig('filter.private.required', 'true')

   gr.setconfig('diff.private.textconv','sr_diff')

   warning("Add patterns to .gitattributes to enable encryption.")
   warning("For example:")
   warning("    *.txt filter=private diff=private")

   config_status(gr)

   warning('''
   If you enable encryption after adding files, they may not be encrypted.
   Run git add command again if necessary. If you have checked-out encrypted
   files before configuration or keys were present, then it may be a bit tricky
   to get git to check-out and decrypt the files. You may need to delete
   .git/index (make sure you haven't stashed something you need), followed by
   git-reset --hard (which will overwrite all files in the working tree).
   Note that files committed unencrypted will remain unencrypted.''')

   if not gr.get_keys():
      warning("Use git-secrepo new or add to install keys.")

def sr_nosmudge():
   'Remove smudge/clean filters but leave diff.'
   gr=git()
   gr.setconfig('diff.private.textconv','sr_diff')
   r = unconfig_note(['filter.private.smudge','filter.private.clean'])
   if r:
      warning('''Working tree encryption/decryption disabled.
   Only temporary decryption for diff/log enabled.
   Working tree files will not be decrypted on check-out.
   Warning: If you have decrypted private files in the working
   tree, they may be checked-in unencrypted.''')

def unconfig_note(keys):
   'Deleted configuration keys returning note of what was deleted.'
   gr=git()
   r=[]
   for c in keys:
     v=gr.getconfig(c)
     if v: r.append("   %-24s %s" % (c,v))
     gr.delconfig(c)

   return r

def sr_config_decrypt():
   '''Decrypt-only configuration.'''
   gr=git()
   gr.setconfig('filter.private.smudge','sr_smudge')
   gr.setconfig('diff.private.textconv','sr_diff')
   unconfig_note(['filter.private.clean'])
   config_status(gr)
      

def sr_config_encrypt():
   '''Encrypt-only configuration.'''
   gr=git()
   gr.setconfig('filter.private.clean','sr_clean')
   unconfig_note(['filter.private.smudge','diff.private.textconv'])

   config_status(gr)

def sr_unconfig():
   gr = git()
   r=unconfig_note([
	'filter.private.smudge',
	'filter.private.clean',
	'diff.private.textconv'])

   if r:
      warning('Configurations removed from local repo:\n'+'\n'.join(r))
   else:
      warning('Configurations removed already.')

   if gr.get_keys():
      warning('note: Keys are still configured.')

   # git config is leaving duplicate empty sections
   for sec in ['filter.private','diff.private']:
      leftover = gr.getsection(sec)
      if leftover:
         warning("You will need to handle extra settings in local repo.")
         warning(leftover)
      else:
         gr.removesection(sec)

def sr_del(keypat,glob):
   '''Delete keys matching name or finger-print'''
   # can operate on global or local config
   if glob:
      gr=gconf()
   else:
      gr=git()

   keys = gr.get_keys_matching(keypat)
   if not keys:
      if glob:
         warning("no global keys keys matched.")
      else:
         warning("no local keys keys matched.")
      return

   sr_listkeys(keypat)
   warning('\n----------------------------------------------------')
   if glob:
      warning("Deleting keys from global scope affecting multiple repos.")
   else:
      warning("Deleting local keys from: "+gr.git_dir)
   warning('\n----------------------------------------------------')
   warning('Removing %d key(s). Data loss will occur if you do not have' % len(keys))
   warning('these keys stored elsewhere. Enter yes in Upper Case to confirm:')

   dk = gr.get_encryption_key()
   if dk:
      if dk in keys:
         warning('Note that you are deleting the default key for encryption.')

   y=user_stdin.readline().strip()
   if y != 'YES':
      warning("cancelled")
      return 1
   gr.delete_keys(keys)
   gr.flush_config()

def sr_delall(glob):
   '''Delete all configured keys.'''
   # can operate on global or local config
   if glob:
      gr=gconf()
      scope='global scope affecting multiple repos.'
   else:
      gr=git()
      scope='local repo.'

   keys=gr.get_keys()
   if not keys:
      warning("no keys.")
      return

   sr_listkeys()
     
   warning('''================================
	Deleting all keys in %s
	Data loss will occur if you do not have these keys stored elsewhere.
	Enter yes in Upper Case to confirm:''' % scope )

   y=user_stdin.readline().strip()
   if y != 'YES':
      warning("cancelled")
      return
   gr.delete_keys(keys)
   gr.flush_config()

def keys_matching(kdict,s):
   '''Return a key dict subset for keys with name or finger-print.'''
   if not s:
      raise SrException("Empty key search parm.")   
   fkeys=dict()
   for k in kdict:
      fp = create_keyfinger(k)
      if kdict[k] == s or fp == s:
         fkeys[k]=kdict[k]
   return fkeys

def sr_export(scope):
   '''Write keys and names to stdout in format that can be imported.'''
   # can operate on global, environment or local config
   if scope == SR_GLOBAL:
      gr=gconf()
   elif scope == SR_ENVIRON:
      gr=srenv()
   else:
      gr=git()

   keys=gr.get_keys()
   if not keys:
      print("# no keys found.")
      return 0

   print("# Copy the following to a file or copy/paste using terminal")
   print("# Lines beginning with # are ignored during import.")
   form="key: '%s' name: '%s'"

   # Note that the default encryption key config is not
   # included, however, we output the default key first
   # so import will make it default if there are no other
   # keys present.
   dkey = gr.get_encryption_key()
   if dkey:
      print("# Default key for encryption: '%s'" % dkey)

      # paranoid check
      if dkey in keys:
         dname=keys[dkey]
      else:
         warning("Local DB is corrupt. Default key name missing.")
         dname='noname'

      print(form % (dkey,dname))
      del keys[dkey]		# this is just a copy
   else:
      print("# No default key for encryption configured on repo.")

   for t in keys:
      print(form % (t,keys[t]))

   print("# End of export")

def sr_import(scope):
   '''Import keys to local repo, global or environment.
   Note that this will override existing names.'''
   # can operate on global, environment or local config
   if scope == SR_GLOBAL:
      gr=gconf()
   elif scope == SR_ENVIRON:
      gr=srenv()
   else:
      gr=git()

   if not flags_quiet:
      if scope == SR_ENVIRON:
         warning("Note that you must eval this command for environment settings to work.")

      warning("Reading import data from stdin.")

   count=0
   errors=0
   ignored=0

   for ln in user_stdin.readlines():
      fds=ln.split()
      if len(fds) > 0 and fds[0][0] != '#':
         if len(fds) == 4 and fds[0] == 'key:' and fds[2] == 'name:':
            # key: 'keyvalue' name: 'keyname'
            key = fds[1].strip("'\"")	# remove quotes
            name = fds[3].strip("'\"")	# remove quotes
            if name and not valid_name(name):
               warning("Invalid name '%s' ignored." % name)
               errors=errors+1
               name=None
            if valid_key(key):
               count = count + 1
               gr.set_key(key,name)
            else:
               warning("Invalid key '%s' ignored." % key)
               errors=errors+1
         else:
            warning('Not processed: "%s"' % ln.strip())
            ignored = ignored + 1

   gr.flush_config()

   if not flags_quiet:
      warning("Summary: %d keys accepted, %d errors, %d lines ignored." %
            (count,errors,ignored))

      warning("   Import to %s completed." % gr.cfg_name)

def sr_listkeys(lmatch=None):
   '''List keys to stdout. Optionally filter by name / finger-print'''
   dk=None
   try:
      gr = git()
      ldefault = gr.get_encryption_key()
      if lmatch:
         lkeys=gr.get_keys_matching(lmatch)
      else:
         lkeys=gr.get_keys()
   except GitNoRepo:
      warning("No git repo found.")
      lkeys=dict()
      ldefault=None

   gl=gconf()
   gdefault = gl.get_encryption_key()

   if lmatch:
      gkeys=gl.get_keys_matching(lmatch)
   else:
      gkeys=gl.get_keys()

   env = srenv()
   edefault = env.get_encryption_key()
   if lmatch:
      envkeys=env.get_keys_matching(lmatch)
   else:
      envkeys=env.get_keys()

   bothkeys=dict()	# superset of config, global and environ keys
   bothkeys.update(envkeys)
   bothkeys.update(gkeys)
   bothkeys.update(lkeys)

   if not bothkeys:
      print("no keys found.")
      return 0

   fp=create_keyfinger

   form=" %-22s %-14s %-18s"
   warning(form % ('Key Name','Finger Print','Scope'))
   warning(form % ('--------','------------','-----'))
   for t in bothkeys:
      scope=[]
      ename=None
      lname=None
      gname=None
      if t in envkeys:
         ename=envkeys[t]
         if t == edefault:
            scope=['Env(d)']
         else:
            scope=['Env']
      if t in lkeys:
         lname=lkeys[t]
         if t == ldefault:
            scope.append('Loc(d)')
         else:
            scope.append('Loc')
      if t in gkeys:
         gname=gkeys[t]
         if t == gdefault:
            scope.append('Glob(d)')
         else:
            scope.append('Glob')

      warning(form % (bothkeys[t],fp(t),' '.join(scope)))
      if gname and bothkeys[t] != gname:
         warning(form % (gname,fp(t),'(different global name)'))
      if ename and bothkeys[t] != ename:
         warning(form % (ename,fp(t),'(different env name)'))

   return 0

def sr_new(name,glob):
   '''Generate a new key with provided name.
 
   Note that sr_new and sr_add are very similar except that
   sr_new generates key and requires confirmation for duplicate
   name, where as, sr_add prompts for the key and warns about
   duplicate name.'''
   # can operate on global or local config
   if glob:
      gr=gconf()
   else:
      gr=git()

   if gr.get_keys_named(name):
      warning("There is a key in this repo with name %s already." % name)
      warning("    Enter YES to confirm:")
      if sys.stdin.readline().strip() != "YES":
         warning("    Cancelled.")
         return False

   k = gr.get_encryption_key()		# encryption key prior to this.

   newkey=b64encode(os.urandom(32))	# 256 bits
   gr.set_key(newkey,name)
       
   warning("New key (%s) generated: '%s'" % (name,newkey))
   gr.new_default_note(k)		# tell user if encryption key changed.

   warning("Record this key to avoid data loss!")
   gr.flush_config()
   return True

def sr_default(keyname,scope):
   'Set the default key for encryption, given key name or finger-print'
   # can operate on global, environment or local config
   if scope == SR_GLOBAL:
      gr=gconf()
   elif scope == SR_ENVIRON:
      gr=srenv()
   else:
      gr=git()

   keys = gr.get_keys_matching(keyname)
   if len(keys) > 1:
      warning("ERROR: '%s' matches %d keys." % (keyname,len(keys)))
      sr_listkeys(keyname)
      return

   if not keys:
      warning("ERROR: no keys matched '%s'" % keyname)
      return

   # keys dict has only one item
   gr.set_default_key(keys.items()[0][0])
   gr.flush_config()

def valid_token(v):
    'Validate token. Screen out problem chars'
    if not v: return False
    for c in ['"',"'"," ","\n","\t",";",","]:
      if v.find(c) > -1: return False
    # ok, could be a valid name or environment string
    return True
 
def split_fields(l):
   '''Split string into fields, removing quotes.
   Separated by spaces, tabs or commas. No embedded
   quotes, commas or white-space allowed.'''
   f = l.replace("'"," ").replace('"',' ')
   return f.replace(',',' ').split()

def valid_env(v):
   'validate environment data'
   if not valid_token(v): return False
   return True
   
def valid_key(key):
   'validate an ascii key / password'
   if len(key) < 7:
      warning("short key: "+key)
      return False

   if not valid_token(key):
      return False

   return True

def valid_name(name):
   'validate a key name'
   if not valid_token(name): return False
   if len(name) > 16:
      warning("long name")
      return False

   return True
 
def env_encryption_key():
   '''Return a key and name from environment that is indicated
   as default key for encryption, or, None,None.'''
   env_default = os_environ.get("SECREPO_DEFAULT")
   if not env_default: return None,None

   key = os_environ.get("SRK_"+env_default)
   if not key: return None,None
   if not valid_key(key): return None,None

   name = os_environ.get("SRN_"+env_default)
   if not valid_name(name):
      name='envdefault'
   return key,name

def sr_wipe():
    'Wipe temporary environment keys. Bourne/posix commands to stdout.'
    count=0
    for k in os_environ:
       if k[:4] == 'SRK_' or k[:4] == 'SRN_':
          if valid_env(k):
             count=count+1
             print("unset '%s';" % k)

    if 'SECREPO_DEFAULT' in os_environ:
       print("unset SECREPO_DEFAULT;")

    if count == 0:
       warning("no environment keys found.")

def sr_reset():
   '''Run git reset and git status in sr_reset_mode.
   This may help deal with encrypted files in the working tree.'''
   os.environ['SR_RESETMODE']='1'
   subprocess.call(['git','reset'])
   subprocess.call(['git','status'])

def srclean_cmd(args):
   '''sr_clean command. Encrypt with header, stdin to stdout.
   If, for some reason, input has a valid header, then pass it
   unchanged. This has the implication that srclean will not,
   change the encryption key for a file that is already encrypted
   unless you first decrypt that file (using a sr_smudge or
   git-secrepo decrypt).
   
   If no default key for encryption is available,
   return failure (rc=2). Must return 0 to indicate success.
   
   Note that git uses the clean filter to bring a file from the
   working tree to store as objects in the repo and/or index.
   It will also use a clean filter to test if the file in the working
   tree is different from the file in the repo/index. This is done by
   git commands such as status, reset and maybe checkout.

   If the output from srclean is identical to the object it already
   has then git assumes the file in the working tree is unchanged.'''
   global sr_log_mode
   global sr_reset_mode

   parser=generic_args()
   cmdargs=process_generic_args(args,parser)

   try:
      # Note that a default key in the environment will override
      # the default key in the repo.
      key,name,src = default_key()	# raises exception if not found
      if src == SR_ENVIRON and not flags_quiet:
         # Because we are encrypting to an environment key, we warn
         # the user. This is not a common scenario.
         warning("secrepo: Using encryption key from environment.")
   except NoKeyAvailable as e:
      e.report()
      return 2		# exit 2 to indicate to git that clean failed.

   # Other exceptions from this function just fall out to user terminal.

   # Local vars key,name,src now refer to default key for encrypted.

   if debug_level:
      debug_log(2,"srclean key='%s' name='%s'" % (key,name))

   # We use raw file input, but this might muck-up sys.stdin/out
   # so try not to use sys.stdin/out for anything else.
   in_file=sys.stdin.fileno()
   out_file=sys.stdout.fileno()
   if is_windoz:
      # For windows we need stdin and stdout to be binary.
      msvcrt.setmode(in_file, os.O_BINARY)
      msvcrt.setmode(out_file, os.O_BINARY)

   # The git repo could override the version I suppose.
   version=git().default_version
   header = Header(version=version,keyname=name,key=key)

   # We read the initial bytes of the file into a buffer which we
   # will compress / encrypt later if it turns out this file does
   # not have a header.
   inbuf=os.read(in_file,header_size)

   # Git appears to handle zero-length files specially, such
   # that if we get zero bytes into our filter, we should just
   # output zero bytes and succeed, otherwise, Git may say that
   # the working tree is modified, even if it is not.
   if len(inbuf) == 0:
      if debug_level:
         debug_log(1,"srclean zero length input.")

      return 0

   # This is not the header, it is a log mode hack
   if inbuf[:8] == 'secrepo ':
      sr_log_mode = False	# logged already

   # hcheck will be a header-object for seeing if the file is
   # already encrypted.
   hcheck=None
   if len(inbuf) == header_size:
      try:
         hcheck=Header(buffer=inbuf)
         if debug_level:
            debug_log(1,"clean already encrypted input (%s)" % hcheck.keyfinger)
      except SrException:
         # header parse failed, so assume not already encrypted.
         pass
   else:
      if debug_level:
         debug_log(1,'srclean only %d bytes recieved.' % len(inbuf))
      # With less than header_size bytes it can't already be encrypted
      # because there is not a valid header.

   if hcheck and src != SR_ENVIRON:
      # If we are using environment default key, don't warn about
      # encrypted files in working tree.
      #
      # We warn the user if we have the key to decrypt this file,
      # but for some reason it is encrypted in the working tree.
      # We can't really fix the problem here because git is using
      # srclean in this instance to check if a file in the working
      # tree is identical to an object in the repo. Because we pass
      # the file unchanged, the files will be identical and git
      # will not check them out again.
      #
      hkey=None
      try:
         hkey=find_decryption_key(hcheck.keyfinger,hcheck.keyname)
         if sr_reset_mode:
            sr_log_mode=True

         # The following would produce excess output during filter-branch
         # so we suppress output using flags_quiet which is set implicitly
         # in the tree-filter (environ GIT_COMMIT).
         #
         if not sr_log_mode and not flags_quiet:
            warning(
  "\nsecrepo: Encrypted file(s) in working tree. You may need to reset --hard\n",
    "         or, delete the affected files from your working tree, or\n",
    "         use secrepo decrypt.")
      except NoKeyAvailable:
         pass

      # Pass the file as-is, but in log mode just output a summary line.
      if not sr_log_mode:
         os.write(out_file,inbuf)
      inbuf = os.read(in_file,32768-header_size)	# align
      size = len(inbuf)		# don't count header size
      while inbuf:
         if not sr_log_mode:
            os.write(out_file,inbuf)
         inbuf = os.read(in_file, 32768)
         size = size + len(inbuf)

      if sr_log_mode:
         sr_log_enc(out_file,hcheck.keyname,hcheck.keyfinger,size,hkey)

      return 0		# exit 0

   header.write(out_file)

   # Supply the prefix bytes already read in order to avoid a pipe here.
   cipher(version).encrypt_stream_to_stream(in_file,key,out_file,prefix=inbuf)

   return 0	# exit 0

def sr_log(parms):
   'Do a git log in mode to see meta-data'
   cmd=['git','log','-p']
   if parms:
      cmd=cmd+shlex.split(parms)

   os.environ['SR_LOGMODE']='1'		# put in pre-exec?
   subprocess.call(cmd)

def sr_log_enc(outfile,keyname,finger,size,key):
   'Report on encrypted file to output stream. Used for log_mode.'
   if key:
      s=f"secrepo encrypted ({keyname}) '{finger}' size={size}\n"
   else:
     s=f"secrepo encrypted unavailable key ({keyname}) '{finger}' size={size}\n"

   os.write(outfile,s.encode())

def sr_drain_log_enc(infile,outfile,keyname,finger,key):
   'Drain input stream, note size and log_enc'
   eof=False
   size=0
   while not eof:
      buf=os.read(infile,32768)
      if buf:
         size=size+len(buf)
      else:
         eof=True

   sr_log_enc(outfile,keyname,finger,size,key)

def sr_log_unenc(out_file,size):
   'Report on unencrypted file to output stream. Used for log_mode.'
   os.write(out_file,"secrepo unencrypted size=%d\n" % size)

def srsmudge_cmd(args,check_only):
   '''sr_smudge command, parse header and decrypt, stdin to stdout.'''
   global sr_log_mode

   parser=generic_args()
   cmdargs=process_generic_args(args,parser)
   # We use raw file input, but this might muck-up sys.stdin/out
   # so try not to use sys.stdin/out for anything else.

   in_fn=sys.stdin.fileno()
   out_fn=sys.stdout.fileno()
   if is_windoz:
      # For windows we need stdin and stdout to be binary.
      msvcrt.setmode(in_fn, os.O_BINARY)
      msvcrt.setmode(out_fn, os.O_BINARY)

   if debug_level:
      debug_log(2,"srsmudge_cmd in=%d, out=%d" % (in_fn,out_fn))
   try:
      rc = smudge_filter(in_fn,out_fn,check_only)
      if check_only:
         if not rc:
            return 1 # exit 1
      return 0			# exit 0 to git

   except NoKeyAvailable as e:
      if sr_log_mode:
         # drain and count stdin
         sr_drain_log_enc(in_fn,out_fn,e.args[0],e.args[2],None)
         return 0

      e.report()
      return 3

   except SrException as e:
      e.report()
      return 2

def smudge_filter(in_file,out_file,check_only=False):
   '''Filter input to output, decrypt and decompress if possible.
   If a header is present, but no key is available, raise an
   exception. If decryption or decompression fails and exception
   is raised. If no header is visible just pass as-is.
   This function should return True to indicate decryption was done.'''
   global sr_log_mode

   gr = git()

   inbuf = os.read(in_file, header_size)

   # Note that zero length files are not encrypted or decrypted.
   # We simply return success with zero length output. This is
   # what Git seems to like. There is similar logic in srclean_cmd.
   #
   if len(inbuf) == 0:
      if debug_level:
         debug_log(1,"smudge zero length input.")

      return 0
   else:
      if debug_level:
         debug_log(2,f"smudge len={len(inbuf)}")

   if inbuf[:8] == 'secrepo ':
      sr_log_mode = False   # logged already
      debug_log(2,f"smudge sr_log_mode False")
   else:
      if debug_level:
         debug_log(2,f"smudge inbuf:8='{inbuf[:8]}'")

   if len(inbuf) < header_size:
      if debug_level:
         debug_log(1,"srsmudge only %d bytes recieved." % len(inbuf))
      if sr_log_mode:
         # In special log mode, we output only a summary line.
         sr_log_unenc(out_file,len(inbuf))
         # We did not actually decrypt, however, because this is a special
         # log mode, return True anyways:
         return True

      # No header, so just pass contents as-is
      if not check_only:
         os.write(out_file,inbuf)
      return False      # no decryption was done

   # The file is large enough to include a header.
   header=None
   try:
      header=Header(buffer=inbuf)
   except SrException as e:
      if debug_level:
         debug_log(2,f"smudge no header: {e}")
      # pass this error unreported because we can handle as
      # unencrypted input.
      pass

   if not header:
      # If no header was seen, the input is not encrypted.
      if debug_level: debug_log(1,"smudge unencrypted input")
      if check_only: return False
      size = len(inbuf)
      if not sr_log_mode:
         if not check_only:
            # pass the file as-is
            os.write(out_file,inbuf)

      inbuf = os.read(in_file,32768-header_size)	# align
      size = size + len(inbuf)
      while inbuf:
         if not sr_log_mode:
            os.write(out_file,inbuf)
         inbuf = os.read(in_file, 32768)
         size = size + len(inbuf)

      if sr_log_mode:
         # In special log-mode, output only a summary.
         sr_log_unenc(out_file,size)
         return True

      return False		# no decryption was done

   # The file included a valid header so we must try and handle it
   # or raise an exception.
   if check_only: return True

   #
   # Using the key fingerprint from the header we will try
   # and get the key.
   #
   key = find_decryption_key(header.keyfinger,header.keyname)
   # get key should raise an exception if it cannot locate the key.
   
   if sr_log_mode:
      sr_drain_log_enc(in_file,out_file,header.keyname,header.keyfinger,key)
      return True
        
   debug_log(2,"sr_smudge key='%s' hname='%s' kf: %s" %
             (key,header.keyname,header.keyfinger))
   try:
      cipher(header.version).decrypt_stream_to_stream(in_file,key,out_file)
   except SrException as e:
      raise DecryptFail("version: %d name: %s finger: %s" %
         (header.version,header.keyname,header.keyfinger), e)

   return True			# Decryption done

class SrConfig:
   '''Super-class for local and global config handling.
   Super-class of Gitrepo and SrGlobal.
   Methods were moved from Gitrepo to here as needed.
   Use the following convention for method names:
   get_ set_ will operate on local object,
   find_ will operate on local object and other scopes.'''
   def __init__(self):
      # It is possible I could allow default version to be overridden
      # per repo (seems unlikely however).
      #
      self.default_version=default_version

   def _read_config(self):
      '''Read keys and settings from config files into self.'''
      (configs,self._keys) = read_config(self.srconfig)

      #
      # The configs dict is not retained currently, however, we could
      # do that if we wanted to keep config parameters by different
      # versions of this script.
      #
      # Unpack known config values into self._c_vars
      # These same ._c_vars will be written back to the config
      # by the write_config method.
      #
      # Currently we only have one config value 'default_key'.
      #
      if 'default_key' in configs:
         self._c_default_key=configs['default_key']
         if self._keys and not self._c_default_key in self._keys:
            warning("Corrupt srconfig. Default key is not in key dict.")

         debug_log(1,"%d keys, default=%s" % (len(self._keys),self._c_default_key))
      else:
         # For working trees using only the diff filter
         # this will happen a lot.
         self._c_default_key=None
         debug_log(1,"%d keys, no default" % len(self._keys))

      self._config_changed=False

      return configs

   def set_default_key(self,key):
      '''Set the default key for encryption in local repo.
      Key must already be in local repo.'''
      if not key:
         raise SrException("Invalid empty default key.")

      if not key in self._keys:
         raise SrException("Default key not already in local repo.")

      if self._c_default_key == key:
         # no change, already default key
         return

      self.mark_changed()
      self._c_default_key = key
      return

   def get_keys_matching(self,s):
      'Return a list of local keys matching string (name or finger-print).'
      return keys_matching(self._keys,s)
   
   def get_keys_named(self,keyname):
      'Return a list of local keys with exact name.'
      fkeys=[]
      for key,name in self._keys.iteritems():
         if name == keyname:
            fkeys.append(key)
      return fkeys
   
   def get_encryption_key(self):
      '''Return the default key for encryption. May be None if it has
      not been configured.'''
      return self._c_default_key

   def get_decryption_key(self,finger):
      '''Look for decryption key in local keystore.
      If not found, return None'''
      return try_keys(self._keys, finger)

   def get_keys(self):
      '''Get keys from configuration in Git repo. Global keys or
      keys in environment variables are NOT included.
      Note that this returns a copy.'''
      td = dict()
      td.update(self._keys)
      # Don't return our .keys in case the caller modifies it.
      return td

   def get_keyname(self,key):
      '''Lookup key in local.
      This is preferred to accessing ._keys directly outside this class.
      Note that local keyname should never be empty or None.'''
      if key in self._keys:
         return self._keys[key]
      return None

   def mark_changed(self):
      self._config_changed=True

   def flush_config(self):
      '''Write changes to config file if needed.'''
      if self._config_changed:
         self.write_config()

   def write_config(self):
      'Write configuration values to file.'
      cd=dict()
      if self._c_default_key:
         cd['default_key']=self._c_default_key
      #
      # Add any other config parms....

      if write_config(self.srconfig, cd, self._keys):
         self._config_changed=False
         return True

      warning("write_config failed for: "+self.srconfig)
      return False

   def delete_keys(self,keys):
      'Delete a list of keys from local repo.'
      for k in keys:
         self.delete_key(k)

   def delete_key(self,key):
      'Delete a local key, specified by exact key password.'
      if not key:
         raise SrException("delete invalid key")

      if self._c_default_key == key:
         self.mark_changed()
         self._c_default_key=None

      if key in self._keys:
         self.mark_changed()
         del self._keys[key]

      # To be consistent, I could remove key from kf_cache
      # kf_cache=dict()
      df=None
      for f,k in kf_cache.items():
         if k == key:
            df=f

      if df: del kf_cache[df]

   def set_key(self,key,name):
      '''Add or change an existing key in local repo.
      Raises an exception if, for any reason key could not be saved.'''
      if not valid_name(name):
         raise SrException("Invalid key name: "+name)
      if not valid_key(key):
         raise SrException("Invalid key")

      if key in self._keys:
         if self._keys[key] == name:
            # No change
            return True

      self.mark_changed()
      self._keys[key]=name

      if not self._c_default_key:
         # If no default key is configured, then this key becomes
         # the default key. This is a bit of an assumption because
         # the set_key interface is also used for imports.
         # No output here. Output in the sr_new if needed.
         # This will fail if we are SrEnv, so SrEnv may set ._c_default_key
         # earlier.
         self.set_default_key(key)

# Global config scope singleton
_gconf_instance=None
def gconf():
   'SrConfig singleton'
   global _gconf_instance
   if _gconf_instance: return _gconf_instance
   _gconf_instance=SrGlobal()
   return _gconf_instance

class SrGlobal(SrConfig):
   '''Singleton to handle global configuration files.'''
   def __init__(self):
      SrConfig.__init__(self)		#super
      self.cfg_name='global config'

      # Read global config
      self.srconfig=os.path.join(os.environ['HOME'],'.'+srconfig_file)
      configs = self._read_config()

   def new_default_note(self,ec):
      '''Warn using if the key they just added is now the default key
      for encryption.'''

      warning("was stored in global config.")

      if not ec and self.get_encryption_key():
         warning("This is now the default key for encryption")
         warning("for global scope (if no local encryption key is set)")

def gitcmd(cmd):
   '''Run git command and return output.
   Use this for git commands that don't produce huge output.
   A CalledProcessError exception is raised if command has
   a non-zero exit. The caller should catch and raise GitFail
   if needed.'''
   if isinstance(cmd,str):
      return cmd_output('git '+cmd)
   else:
      return cmd_output(['git']+cmd)

def gitdir():
   'Get the git repo director, or raise GitFail.'

   # For now, we allow the environment variable to override. This
   # will also perform better in a tree-filter.
   git_dir = os.environ.get("GIT_DIR")

   if git_dir:
      if debug_level: debug_log(2,"GIT_DIR: "+git_dir)
      return git_dir

   try:
      git_dir = gitcmd(['rev-parse','--git-dir'])
   except CalledProcessError as e:
      raise GitNoRepo()

   if not git_dir: raise GitFail('no git dir?')

   if not os.path.isdir(git_dir):
      raise GitFail('cannot access git dir: '+self.git_dir)

   try:
      return git_dir.decode()
   except:
      return git_dir

# SrEnv singleton
_srenv_instance=None
def srenv():
   'SrEnv singleton'
   global _srenv_instance
   if _srenv_instance: return _srenv_instance
   _srenv_instance=SrEnv()
   return _srenv_instance

class SrEnv(SrConfig):
   '''Class to represent keys configured in environment.'''
   def __init__(self):
      SrConfig.__init__(self)		#super
      configs = self._read_config()
      self.cfg_name='environment'
      self.env_slots=set()

   def _read_config(self):
      '''Read keys and settigns from environment into self.'''

      # TODO: import the logic into this method and depricate other methods
      self._c_default_key,name = env_encryption_key()
      self._keys=self._env_keys()

      self._config_changed=False
      return None

   def _env_keys(self):
      '''Get temporary keys from environment. Some validation done.
      Returns dict of keys with names. Default name 'env' is used
      if there is no name in the environment.'''
      d=dict()
      for evar in os_environ:
         if evar[:4] == 'SRK_' and len(evar) > 4:
            if valid_env(evar):
               key=os_environ[evar]
               if valid_key(key):
                  nvar='SRN_'+evar[4:]
                  if nvar in os_environ:
                     d[key] = os_environ[nvar]
                  else:
                     # Name is optional for environment keys.
                     # We put in the default name 'env'.
                     d[key]='env'
               else:
                  warning("Invalid key in: "+evar)

      if debug_level: debug_log(1,"env_keys:",d)
      # warning("env_keys:",d)
      return d

   def set_default_key(self,key):
      '''Set default key in environment. It is assumed that some validation
      has already been done on key.'''
      for v in os_environ:
        if v[:4] == 'SRK_':
           if os_environ[v] == key:
              self._c_default_key=key	# for consistancy with other classes
              print("export SECREPO_DEFAULT='%s';" % v[4:])
              # No point is actually updating the environ
              return

      # It is an error to assign a default key that is not already known.
      raise SrException('Env key (%s) not found.' % key)

   def flush_config(self):
      '''Write changes to config file doesn't apply to environ.'''
      debug_log(1,'SrEnv.flush_config()')
      self._config_changed=False

   def write_config(self):
      '''Doesn't apply to environment. Probably an error.'''
      raise SrException('SrEnv.write_config()')

   def delete_key(self,key):
      '''Delete a key from environment (output eval commands).'''
      defaultkey=os_environ.get('SECREPO_DEFAULT')

      SrConfig.delete_key(self,key)	# super
      for v in os_environ:
         if v[:4] == 'SRK_':
            if os_environ[v] == key:
               print("unset '%s';" % v)
               print("unset '%s';" % 'SRN_'+v[4:])
               if defaultkey:
                  if defaultkey == v[4:]:
                     print("unset SECREPO_DEFAULT;")

               # Probably no point in actually modifying environment
               # for this process.
               return

   def set_key(self,key,name):
      '''Set a key in the environment (output eval commands).'''
      if self._c_default_key:
         revert=False
      else:
         revert=True
         self._c_default_key = key	# avoid assumption in superclass

      SrConfig.set_key(self,key,name)	# super
      self.set_env_key(key,name)
      if revert: self._c_default_key=None

   def new_default_note(self,ec):
      '''Provide info about added key.'''
      warning("key added to environment (eval commands).")
      # Note that we do not automatically set an encryption key
      # in the environment.
      
   def set_env_key(self,key,name=None):
      '''Set a key and optional name in environment using posix shell
      eval stdout. No checks or assumptions on local git or global
      config. Existing environment is handled.
      Returns environment slot number updated.'''
   
      for x in xrange(1,50):
         ev = "SRK_%d" % x
         if ev in os_environ:
            if os_environ[ev] == key:
               # That key is already in environment. Just update
               # name if it is provided.
               if name:
                  print("export SRN_%d='%s';" % (x,name))
               else:
                  print("unset SRN_%d;" % x)
               return x
      
      for x in xrange(1,50):
         if not x in self.env_slots and not "SRK_%d" % x in os_environ:
            print("export SRK_%d='%s';" % (x,key))
            if name:
               print("export SRN_%d='%s';" % (x,name))
            else:
               print("unset SRN_%d;" % x)
            
            self.env_slots.add(x)	# mark slot as used.
            return x
      
      raise SrException("No environment space.")

# Gitrepo singleton
_git_instance=None
def git():
   'Gitrepo singleton'
   global _git_instance
   if _git_instance: return _git_instance
   _git_instance=Gitrepo()
   return _git_instance

class Gitrepo(SrConfig):
   '''Class to represent the current repo and working tree.
   Some methods on this class will query keys in the environment
   or global, however, methods on this class will not modify
   keys in the environment or global. The configuration saved
   from this class will not include keys from the environment
   or global.'''
   def __init__(self):
      SrConfig.__init__(self)		#super
      self.cfg_name='local repo config'

      self.git_dir = gitdir()

      # Read local config
      self.srconfig=os.path.join(self.git_dir,srconfig_file)
      configs = self._read_config()

   def setconfig(self,key,val):
      'Set a configuration value in git. Returns True if it appears to work.'
      try:
         o = gitcmd(['config',key,val])
         return True
      except CalledProcessError as e:
         warning(e.__str__())
         if e.output: warning("    output: "+e.output)

      return False

   def getconfig(self,key):
     '''Get git config value. Returns None if value not in git config.
     Note that git can return an empty-string config value.'''
     try:
       return gitcmd(['config','--get',key])
     except CalledProcessError as e:
       # git rc=1 if the value is not found.
       # I return None for not-found because empty-string might actually
       # be a valid value?
       return None

   def delconfig(self,key):
      '''Delete a git config value.
      Returns True if a config change was made.
      Returns False if no config change was made because value was not set.'''
      try:
         gitcmd(['config','--unset',key])
         return True
      except CalledProcessError as e:
         # git rc=5 if value was not configured (i.e. no change).
         # We simply return False
         if e.returncode == 5: return False
         # Instead of warning here, should I raise GitFail?
         warning("Unexpected rc=%d from git config --unset "+key,e)

   def getsection(self,section):
      '''Get the contents of a git config section.
      Returns None if empty.'''
      try:
         return gitcmd(['config','--get-regexp',section])
      except CalledProcessError:
         return None

   def removesection(self,section):
      '''Remove a section from the git config.
      Return True if something was removed.'''
      try:
         gitcmd(['config','--remove-section',section])
         return True	# section removed
      except CalledProcessError:
         return False	# no change

   def new_default_note(self,ec):
      '''Warn using if the key they just added is now the default key
      for encryption.'''

      warning("was stored in local config.")

      if not ec and self.get_encryption_key():
         warning("This is now the default key for encryption")
         warning("for local scope (overrides global and environment).")

# To speed the secrepo decrypt command which handles multiple files
# we create a faster map from key finger-print to key.
kf_cache=dict()

def find_decryption_key(finger,name):
   '''Get decryption key from local, environment or global.
   Exception is raised if key is not found.
   Key name will be included in exception but is not used otherwise.'''
   if not finger:
      raise SrException("find_decryption_key no fingerprint provided.")

   if not name:
      # Can't think of a valid reason for this because all headers
      # are now required to have a name field.
      raise SrException("find_decryption_key no name provided.")

   # Have we found this already
   if finger in kf_cache:
      return kf_cache[finger]

   # For performance reasons, try environment first.
   key = srenv().get_decryption_key(finger)
   if key:
      # Found a usable key in environment.
      kf_cache[finger]=key
      return key

   # For speed, try local keys first.
   # I could use a try: block to allow operation outside of a repo
   key = git().get_decryption_key(finger)
   if key:
      # Found a usable key in local keystore.
      kf_cache[finger]=key
      return key

   # Try global scope
   gc = gconf()
   key = try_keys(gc.get_keys(), finger)
   if key:
      # Found a usable key in global store.
      kf_cache[finger]=key
      return key

   # TODO:	Look into other location(s) for the key.
   #		- ~/.srconfig
   #		- kernel keyring
   #		- gnome keyring
   #		- gpg keyring

   raise NoKeyAvailable(name,None,finger)

def default_key():
   '''Return the default key and name and key source for encryption.
   Never returns key '' or None.
   Exception is raised if default key is not available.
   Looks in environment, local repo and global keystore.'''

   key = srenv().get_encryption_key()
   # May need warning if encrypting to environment key
   if key: return key, srenv().get_keyname(key), SR_ENVIRON

   key = git().get_encryption_key()
   if key: return key, git().get_keyname(key), SR_LOCAL

   key = gconf().get_encryption_key()
   if key: return key, gconf().get_keyname(key), SR_GLOBAL

   raise NoDefaultEncryptionKey("default")
      
# From python 2.7 subprocess.py
# Remove this later and just use the subprocess implementation.
def check_output(*popenargs, **kwargs):
   if 'stdout' in kwargs:
      raise ValueError('stdout argument not allowed, it will be overridden.')
   process = Popen(stdout=PIPE, *popenargs, **kwargs)
   output, unused_err = process.communicate()
   retcode = process.poll()
   if retcode:
      cmd = kwargs.get("args")
      if cmd is None:
         cmd = popenargs[0]
      raise CalledProcessError(retcode, cmd, output=output)
   return output

def cmd_output(cmd,errout=subprocess.STDOUT):
   '''Run a command. For the most part, this is a wrapper
      around subprocess.check_output, however, this utility
      provides a convenient place to do some latency measurements,
      logging and debugging if needed. I also use shlex
      parsing here to allow a string as well a list to be
      passed in. The output value is stripped because there is
      often a trailing newline we don't want.
      check_output will raise CalledProcessError on non-zero rc'''

   # to make use a bit easier, I split the cmdlist if necessary
   if isinstance(cmd,str):
      cmd=shlex.split(cmdlist)

   # return subprocess.check_output(cmd,stderr=errout).strip()
   # To support python < 2.7
   return check_output(cmd,stderr=errout).strip()

def file_is_encrypted(fn):
   '''Perform a simple test to see if file is encrypted.'''
   try:
      h = Header(fn)
      return True
   except InvalidHeader:
      pass

   return False

def file_md5sum(fn):
    '''Return md5sum of file as hex string'''
    # Using hashlib.md5 to do this instead of external md5sum
    # because it will probably perform better for
    # small files and will perform ok even for big files.
    readf=open(fn,'rb')
    md5hash=hashlib.md5()

    # Read the data in chunks until the hash stops changing
    # because we are not longer getter more data.
    # Not sure what the optimal chunk size is.
    prev=''
    while prev != md5hash.digest():
       prev=md5hash.digest()
       md5hash.update(readf.read(32768))

    readf.close()
    return md5hash.hexdigest()

    # Should I catch and normalize exceptions into SrException for
    # more gracefull reporting?
    # IOError (from open) or CalledProcessError (from external md5sum).
    # except SrException as e:
    #    raise SrException("md5sum "+fn,e)

def edit_existing_file(editfile):
    '''Edit a non-encrypted file. Return True if changes were made.'''
    if "EDITOR" in os_environ:
       editor_cmd = [os_environ["EDITOR"]]
    else:
       editor_cmd = default_editor

    if debug_level: debug_log(1,"Using editor:",editor_cmd)

    orig_sum=file_md5sum(editfile)

    subprocess.call(editor_cmd+[editfile])

    new_sum=file_md5sum(editfile)

    if new_sum == orig_sum:
       return False	# unchanged

    return True		# changed

def mkstemp():
  return tempfile.mkstemp(dir=tmpfs)

def get_tmpfile():
    # more secure.
    # TODO: use tempfile.mkstemp()
    
    fd,fname = mkstemp()
    os.close(fd)
    return fname

class DecompStat:
  '''Status of the decompressor'''
  def __init__(self):
    self.success=False
    self.inbytes=0	# excluding Gzip suffix ?header
    self.outbytes=0
    self.error_msg=''
  def record_in(self,dlen):
    self.inbytes = self.inbytes+dlen
  def record_out(self,dlen):
    self.outbytes = self.outbytes+dlen
  def record_success(self):
    self.success=True

# A couple of utilities (ref: Gzip.py write32u read32)
def pack32u(value):
    # The L format writes the bit pattern correctly whether signed
    # or unsigned.
    return struct.pack("<L", value)

def unpack32(bindat):
    return struct.unpack("<I", bindat)[0]

v1_cipher=None
def cipher(version):
   'v1 cipher singleton'
   global v1_cipher
   if version == 1:
      if not v1_cipher:
         v1_cipher = StreamCipher_v1()
      return v1_cipher
   raise DecryptFail("unsupported version %d" % version)

class StreamCipher:
   '''Super-class for stream ciphers.
   For now, stream-ciphers are stateless and may be Singletons, however
   in the future, I might add the key to the constructor, or, add methods
   to this class to search for decryption key based on fingerprint because
   the version is known at that point.
   Initially, all the implementation will go in this class. When v2 is added,
   the differences will be migrated into subclasses.'''
   def __init__(self):
      '''Nothing to see here.'''
      pass

   def compress_thread(self,infile,outfile,prefix):
      '''Thread that compresses a stream of data.
      Optional prefix buffer is processed first.'''

      # GzipFile needs a python file object
      # TODO: replace Gzip with zlib.
      # See Gzip._write_gzip_header
      # write('\037\213\010\000\000\000\000\002\377')
      # We would also have to add the suffix with size and crc, so,
      # there is probably little value is changing to zlib.
      #
      if isinstance(outfile,int):
         of = os.fdopen(outfile,'wb')
      else:
         of = outfile

      outfile=None

      zf = gzip.GzipFile(filename='',mode='wb',mtime=0,
            fileobj=of,compresslevel=9)

      eof = False
      while not eof:
         if prefix:
            # process prefix bytes first
            buf = prefix
            prefix = None
         else:
            # Read a block of input data
            if isinstance(infile,int):
               # from a raw (os-level) file.
               buf=os.read(infile,32768)
            else:
               # from a python buffered file.
               buf=infile.read(32768)

         if buf:
            # If we got some data, write it to the compressor
            # Here we hope that zlib releases the global execution lock
            # so other python threads are not blocked while it is crunching
            # in C.
            zf.write(buf)
         else:
            # We got no data, so we are at the end of input
            eof = True

      zf.close()	# finish the compression

      # In order to allow the ssl encryptor to unblock and finish, we need
      # to close out output stream here (the ssl encryptor is reading from
      # this). My hope is that the zf.close() above will do that automatically,
      # however, if it does not for some reason we can do it here:
      of.close()

   def decompress_thread(self,infile,outfile,stat):
      '''Thread that decompresses a stream of data. Note that the
      input stream will be closed in the event of an error.'''

      # GzipFile needs a real python file object, not just a stream.
      # This is problem which is solved in python3. In python2 we
      # could just use zlib directly, or, we could write the
      # data to a temporary file first.

      # Some docs indicate that a negative value should be used
      # to allow for Gzip header. This is what gzip.py does.
      # In our case we use a value > 30 which, for some reason
      # triggers zlib to verify the gzip header and trailing crc and size.
      # Seriously, I tried it, see fault injection code below.
      zd = zlib.decompressobj(zlib.MAX_WBITS+16)

      try:
         eof=False
         while not eof:
            # Read some compressed data from stream
            if isinstance(infile,int):
               # from raw stream
               buf=os.read(infile,32768)
            else:
               # from buffered stream
               buf=infile.read(32768)

            # Note amount of input data and detect eof
            if buf:
               # Fault injection test:
               #if len(buf) > 8 and len(buf) < 32768:
               #   # probably EOF
               #   crc32 = unpack32(buf[-8:-4])
               #   isize = unpack32(buf[-4:])
               #   warning("zdata eof crc=%d isize=%d" % (crc32,isize))
               #   # corrupt the CRC
               #   # buf=buf[:-8]+'abcd'+buf[-4:]
               #   # corrupt the length
               #   buf=buf[:-4]+'abcd'
               # End fault injection test

               stat.record_in(len(buf))
               # decompress the data
               dbuf=zd.decompress(buf)
            else:
               eof=True
               dbuf=zd.flush()	# get any remaining data from decompress

            if dbuf:
               stat.record_out(len(dbuf))	# note amount

               # Write the block of decompressed data.
               if isinstance(outfile,int):
                  # to a raw (os-level) file.
                  os.write(outfile,dbuf)
               else:
                  # to a python buffered file.
                  outfile.write(dbuf)

         # No more compressed data.
         stat.record_success()
         if debug_level: debug_log(1,"decompress success in: %d out: %d" %
                  (stat.inbytes,stat.outbytes))

      except zlib.error as e:
         # Decompression failed, probably because input stream
         # was not correct.
         stat.error_msg="zlib.error "+str(e)

      finally:
         # If decompress fails for any reason, this should signal to
         # the write-side of the pipe that it has failed.
         if isinstance(infile,int):
            os.close(infile)
         else:
            infile.close()

      # outfile may be stdout, so we can't really close it here,

   def encrypt_stream_to_stream(self,instream,key,fstream,prefix=None):
      if debug_level: debug_log(2,"encrypt:",instream,key,fstream)

      (ssl_read_pipe,gzip_write_pipe) = os.pipe()

      # Create a thread that reads the clear data and sends the compressed data
      # output to the openssl encryptor pipe.
      # Any prefix buffer is passed to the thread to be processed first.
      #
      gzthread=threading.Thread(target=self.compress_thread,
            args=(instream,gzip_write_pipe,prefix))
      gzthread.setDaemon(True)
      gzthread.start()

      # Ideally we would close the input stream after we join the gzthread,
      # but it could be stdin, so we should just leave it alone and
      # not reference it any more.
      instream=None	# read in thread
      prefix=None		# processed in thread

      self.aes_encrypt(ssl_read_pipe,fstream,key)
      os.close(ssl_read_pipe)

      # Ideally we would close output file here, however, it might be
      # stdout, so just remove any references to it. It is up to caller
      # that created stream to close/flush it.
      fstream=None

      gzthread.join()

      # Doesn't seem to be any return code from the GzipFile object.

   def encrypt_file_to_stream(self,fn,key,stream):
       '''Encrypt file to a stream.
       Note that we currently support a buffered stream or a fileno,
       however, I should just pick one or the other :)
       Caller must close the destination stream if needed.'''

       fd=os.open(fn,os_read)
       try:
          rc = self.encrypt_stream_to_stream(fd,key,stream)
          return  rc
       finally:
          os.close(fd)

   def decrypt_stream_to_stream(self,instream,key,outstream):
    '''Decrypt a stream into a file. Stream is then closed.
    Note that I support buffered streams and a fileno.
    I should pick just one  :)
    Caller must close streams if needed.'''

    (gunzip_read_pipe,ssl_write_pipe) = os.pipe()
    dstatus=DecompStat()

    # Create a thread that reads the decrypted data and decompresses it.
    gzthread=threading.Thread(target=self.decompress_thread,
          args=(gunzip_read_pipe,outstream,dstatus))
    gzthread.setDaemon(True)
    gzthread.start()

    # The caller will close/flush the outstream, we don't need
    # to reference it any more here. The gzthread still has it.
    outstream=None

    decrypt_success=False
    try:
       self.aes_decrypt(instream,ssl_write_pipe,key)
       decrypt_success=True
    finally:
       # Note that the decompressor will block until it gets EOF on its
       # pipe or decompress fails.
       os.close(ssl_write_pipe)
       # In the exception case I need to finish gzthread.
       # I I did not want to .join here, I guess I could simply
       # sleep for a second, but that would be a visible delay.
       if not decrypt_success:
          gzthread.join()

    # Ideally we would close the input stream, however, it might be
    # stdin, so just drop any references to it.
    instream=None

    # If incorrect decryption key is used then gz may exit without
    # reading all the output, in which case openssl could then be
    # blocked on it's stdout pipe? With bourne-shell, I think openssl
    # would get some signal about writing to a closed pipe.
    # Hopefully that is what happens here also. The gzthread
    # will close the read pipe on a failure.

    gzthread.join()

    if not dstatus.success:
       if debug_level:
          debug_log(1,"gunzip did not complete (%d output)" % dstatus.outbytes)
       # It is possible that gunzip failed because the decryption
       # failed. In any case, we are not going to get any useful output.
       raise GunzipFail(dstatus.error_msg)

    if dstatus.outbytes == 0:
       if debug_level: debug_log(1,"no output. Input: %d" % dstatus.inbytes)

    if decrypt_success: return

    raise DecryptFail('_v1 decrypt_fail')

   def decrypt_stream_to_file(self,stream,key,fn):
      # if destination exists, remove it
      if os.path.isfile(fn): os.unlink(fn)
      fd=os.open(fn,os_create)
      success=False
      try:
         rc = self.decrypt_stream_to_stream(stream,key,fd)
         protect_file(fn)
         success=True
         return rc
      finally:
         os.close(fd)
         # If the operation was not successfull, then discard
         # any file created.
         if not success:
            if os.path.isfile(fn):
               debug_log(1,"removing %s due to failure." % fn)
               os.unlink(fn)

   # Encrypt aes-256-cbc -nosalt
   # ref: http://stackoverflow.com/questions/16761458/how-to-aes-encrypt-decrypt-files-using-python-pycrypto-in-an-openssl-compatible
   #
   def derive_key_and_iv(self, password, key_length, iv_length):
      '''Create key and iv from password without salt. Note that this does
      not appear as strong as some newer mechanisms, however, it is compatible
      with openssl. password is bytes, output is bytes.'''
      d = d_i = b''
      while len(d) < key_length + iv_length:
        d_i = hashlib.md5(d_i + password).digest()
        d += d_i
      return d[:key_length], d[key_length:key_length+iv_length]

   def aes_encrypt(self, in_file, out_file, password, key_length=32):
      '''Encrypt a stream, output in openssl aes-256-cbc compatible form.'''
      bs = AES.block_size
      key, iv = self.derive_key_and_iv(password, key_length, bs)
      debug_log(2,f"encrypt: {password} key: {key} iv: {iv}")

      cipher = AES.new(key, AES.MODE_CBC, iv)
      finished = False
      while not finished:
         # 1024 aes 'blocks' of 16 bytes each.
         if isinstance(in_file,int):
            chunk = os.read(in_file,1024 * bs)
         else:
            chunk = in_file.read(1024 * bs)

         # We got no data or less data than asked for, assume
         # EOF.
         if len(chunk) == 0 or len(chunk) % bs != 0:
            # Because the cipher only operates on fixed size
            # blocks, we add some additional padding to the
            # last chunk. This padding must be removed when
            # decrypting. Note that there is always some padding
            # added, even if this requires adding an additional
            # block.
            padding_length = bs - (len(chunk) % bs)
            chunk += bytes(padding_len * [padding_len])
            finished = True

         if isinstance(out_file,int):
            os.write(out_file,cipher.encrypt(chunk))
         else:
            out_file.write(cipher.encrypt(chunk))

   def aes_decrypt(self, in_file, out_file, password, key_length=32):
      '''Decrypt a stream in openssl aes-256-cbc form.'''
      bs = AES.block_size
      p=password.encode()   # password is string
      key, iv = self.derive_key_and_iv(p, key_length, bs)
      debug_log(2,f"decrypt: {password} key: {key.hex()} iv: {iv.hex()}")
      cipher = AES.new(key, AES.MODE_CBC, iv)
      next_chunk = b''
      finished = False
      while not finished:
         chunk = next_chunk
         try:
            if isinstance(in_file,int):
               next_chunk = cipher.decrypt(os.read(in_file,1024 * bs))
            else:
               next_chunk = cipher.decrypt(in_file.read(1024 * bs))

         except ValueError as e:
            # The .decrypt method above will raise exception if input
            # length is not a multiple of bs
            raise DecryptFail("aes_decrypt cipher.decrypt",e)

         if len(next_chunk) == 0:
            # Look at the last byte of the last chunk to
            # determine the amount of padding to be removed.
            pad_len = chunk[-1]
            if pad_len < 1 or pad_len > bs:
               # Padding length should be 1..bs
               debug_log(1,"padding_length: %d" % pad_len)
               raise DecryptFail("aes_decrypt missing pad (%d)" % pad_len)

            # To be really safe, I need to check that all the chars
            # I am deleting are equal to chunk[-1]
            # This is probably similar to the bad magic number
            # error from the openssl program.
            if chunk[-pad_len:] != bytes(pad_len * [pad_len]):
               raise DecryptFail("aes_decrypt pad check failed.")

            chunk = chunk[:-pad_len]	# delete pad bytes
            finished = True

         if chunk:
            if isinstance(out_file,int):
               os.write(out_file,chunk)
            else:
               out_file.write(chunk)

# from subprocess
def _readerthread(fh, buffer):
    buffer.append(fh.read())

# 80 bits (10 bytes) unique value to identify correct key.
# Another 48 bits (6 bytes) of key data is added to this
# in order to make a 16 byte (128 bit) AES block.
try:
    key_check_val=bytes.fromhex('34486745608c9cd13864')
except:
    key_check_val=str.decode('34486745608c9cd13864','hex')

def create_keyfinger(password):
    '''Create a key fingerprint that can be used to check a given key is
    correct. This value can be included in the Header to allow checking of
    keys before payload decryption is attempted.
    Returned value is b64 encoded and trimmed to 66 bits (11 chars)
    for inclusion in header. I don't want to put the entire 256 bits
    into the header, in part to save space but also to reduce the
    exposure on the key.'''
    return b64encode(SHA256.new(password.encode()+b'This is SecRepo transparent Git encryption.').digest())[:11]

def slow_keyfinger(password, key_length=32):
    '''Create a 128 bit block (16 byte) key fingerprint that can be
    used to check a given key is correct. This value can be included
    in the Header to allow checking of keys before payload decryption
    is attempted. password is a string.
    Returned value is b64 encoded and trimmed to 66 bits (11 bytes)
    for inclusion in header. I don't want to put the entire 128 bits
    into the header, in part to save space but also to reduce the
    exposure on the key.'''
    p=password.encode()
    if len(p) < 6:
       raise SrException("Password is less than 6 chars")
    key, iv = cipher(1).derive_key_and_iv(p, key_length, AES.block_size)
    aes = AES.new(key, AES.MODE_CBC, iv)
    return b64encode(aes.encrypt(key_check_val+p[:6]))[:11]

def try_keys(kdict,finger):
   '''Try each key in dict against some check_data.
   Valid key or None is returned.'''
   for key in kdict:
      if finger == create_keyfinger(key):
         return key
      # temporary
      if finger == slow_keyfinger(key):
         return key

   return None

class StreamCipher_v1(StreamCipher):
   '''Version 1 stream cipher'''
   def __init__(self):
      StreamCipher.__init__(self)

class Header:
  '''Class to extract and hold header data from encrypted file.'''
  def __init__(self,file=None,version=None,keyname=None,key=None,buffer=None):
    '''initialize with a filename or a stream or version and key info'''
    if version:
       self.version=version

       if not keyname: raise SrException("Header with no keyname")
       # We include a logical key name in the header to
       # provide a readable comment line in git log -p even
       # when key is not available.
       self.keyname=keyname

       if not key: raise SrException("Header with no key")
       # Create a key fingerprint for inclusion in the header.
       # This will allow key validation during decryption.
       self.keyfinger=create_keyfinger(key)
       return

    if buffer:
       if len(buffer) < header_size:
          raise InvalidHeader("buffer only %d bytes" % len(buffer))

       self.populate_from_buffer(buffer[:header_size])
       return

    if isinstance(file,str):
       try:
          tmpfd=open(file,'rb')
       except IOError as e:
          raise InvalidHeader("File access error",e)
       try:
          self.populate_from_stream(tmpfd)
       finally:
          tmpfd.close()
    else:
       self.populate_from_stream(file)

  def write(self,stream):
     '''write header to stream.'''
     if not self.version: raise InvalidHeader("incomplete while writing")
     if not self.keyname: raise InvalidHeader("no key name while writing")
     if not self.keyfinger: raise InvalidHeader("no keyfinger while writing")

     h='{SecREPO}\n%d\n%s\n%s%40s' % (self.version,self.keyname,self.keyfinger,'')

     # unbuffered io is preferred
     if isinstance(stream,int):
        os.write(stream,h[:header_size])
     else:
        stream.write(h[:header_size])
        # note that it is up to caller to flush this stream if needed.
        # TODO: phase out use of buffered io unless it works well with _v3

  def populate_from_stream(self,stream):
     '''Read stream to populate header or raise InvalidHeader'''
     try:
        # For reading, we support a fileno as well
        # as a buffered stream. Note that the buffered stream
        # does not integrate smoothly with Popen
        if isinstance(stream,int):
           hdata=os.read(stream,header_size)
        else:
           # TODO: phase out use of buffered io unless it works well with _v3
           hdata=stream.read(header_size)

     except (ValueError,IOError) as e:
        raise InvalidHeader("error reading stream",e)

     return self.populate_from_buffer(hdata)

  def populate_from_buffer(self,buf):
     '''Read buffer to populate header or raise InvalidHeader'''
     if len(buf) < header_size:
        raise InvalidHeader("less than %d bytes" % header_size)

     try:
        hdata = buf.split()
        if debug_level:
           debug_log(2,f"populate hdata: {hdata}")
        
        if (len(hdata) != 4) or (hdata[0] != b'{SecREPO}'):
           raise InvalidHeader('No valid prefex')

        v = int(hdata[1])
        if v != 1:
           raise InvalidHeader('no valid version (%d)' % v)

        self.version=v
        self.keyname=hdata[2]
        self.keyfinger=hdata[3]

     except ValueError as e:
        raise InvalidHeader("corrupt value",e)

  def __str__(self):
     if self.version == None:
        return "uninitalized"
     return "version: %d name: %s fp: %s" % (self.version,self.keyname,self.keyfinger)

def sr_encrypt():
   '''Touch non-encrypted files (read list from stdin) so git will pick it
   up and encrypt it.'''
   if flags_verbose: warning("Reading filenames from stdin:")
   errors=0
   touched=0
   encrypted=0
   for x in sys.stdin.readlines():
      qfilename=x.strip()	# readlines puts \n on the end?
      if qfilename:	# skip blank lines
         # ls-files may quote and escape chars, undo this.
         # Another option would be to require ls-files -z
         filename=c_style_unescape(qfilename)
         try:
            if not os.path.islink(filename):
               if file_is_encrypted(filename):
                  encrypted += 1
               else:
                  os.utime(filename,None)
                  touched += 1

         except SrException as e:
            errors += 1
            if debug_level:
               e.report()

         except OSError as e:
            errors += 1
            if debug_level:
               warning("During `encrypt` '%s'" % filename,exception=e)

         except IOError as e:
            errors += 1
            if debug_level:
               warning("During `encrypt` '%s'" % filename,exception=e)

   if not flags_quiet:
      warning("Encrypt complete:")
      warning("   Errors:            %6d" % errors)
      warning("   Already Encrypted: %6d" % encrypted)
      warning("   Touched:           %6d" % touched)

def sr_decrypt(filename):
   '''Decrypt a file in-place.'''
   if filename:
      #
      # Single File Mode
      #
      try:
         rc = decrypt_file(filename)
         if rc == 0:
            warning("Decryption complete for "+filename)
            return
         elif rc == 2:
            warning("%s is not encrypted. No changes made." % filename)
            return
         elif rc == 3:
            warning("%s is symlink. No changes made." % filename)
            return

         # decrypt_file() reported error message
         return
      except NoKeyAvailable as e:
         e.report()
         return

   #
   # Multiple File Mode
   #
   if flags_verbose: warning("Reading filenames from stdin:")
   errors=0
   success=0
   not_encrypted=0
   missing_key=0
   ignored=0

   missing_keys=dict()
   for x in sys.stdin.readlines():
      qfilename=x.strip()	# readlines puts \n on the end?
      if qfilename:		# skip blank lines
         # ls-files may quote and escape chars, undo this.
         # Another option would be to require ls-files -z
         filename=c_style_unescape(qfilename)
         try:
           rc = decrypt_file(filename)
           if rc == 0:
              success +=1
           elif rc == 2:
              not_encrypted +=1
           elif rc == 3:
              ignored +=1
           else:
              errors +=1

         except NoKeyAvailable as e:
           missing_keys[e.args[2]]=e.args[0]
           missing_key +=1
           if not flags_quiet: warning("Missing key for "+filename)

   if not flags_quiet:
      warning("Completed decryption operation:")
      warning("   %-4d files decrypted." % success)
      warning("   %-4d files not encrypted (no change made)" % not_encrypted)
      warning("   %-4d files no decryption key available." % missing_key)
      warning("   %-4d other errors." % errors)

      if missing_keys:
         form = '%-14s %-20s %-14s'
         warning(form % ('Missing keys:','Name','Finger Print'))
         warning(form % ('',             '----','------------'))
         for k in missing_keys:
            warning(form % ('',missing_keys[k],create_keyfinger(k)))

# copied from:
# https://github.com/felipec/git-remote-hg/blob/master/git-remote-hg
def c_style_unescape(string):
    if string[0] == string[-1] == '"':
       return string.decode('string-escape')[1:-1]
    return string

def decrypt_file(filename):
   '''Decrypt a file in-place.
   Return 0 for success.
   Return 1 for error.
   Return 2 for not encrypted.
   Return 3 for not a plain file (symlink)'''

   tmp=filename+'.tmp'

   if os.path.islink(filename):
      # Because we are doing in-place decryption it is not appropriate
      # to follow symlinks.
      return 3

   if not os.path.isfile(filename):
      if not flags_quiet: warning("no such file: "+filename)
      return 1

   infile = open(filename,'rb')
   try:
      header = Header(infile)
      key = find_decryption_key(header.keyfinger, header.keyname)
   except InvalidHeader:
      return 2		# Not encrypted
   finally:
      infile.close()

   if os.path.isfile(tmp):
      warning("%s exists. Cannot proceed." % tmp)
      return 1		# Error reported

   shutil.copyfile(filename,tmp)
   if not os.path.isfile(tmp):
      warning("Could not create %s. Failed." % tmp)
      return 1		# Error reported

   outfile = None
   tmpfile = None
   success = False
   try:
      # Hopefully this will open the file in-place without
      # changing any permissions.
      outfile = os.open(filename,os_overwrite)
      tmpfile = os.open(tmp,os_read)
      Header(tmpfile)

      cipher(header.version).decrypt_stream_to_stream(tmpfile, key, outfile)

      # Truncate output file to current position.
      # Python 3.3 may have a better API for this:
      os.ftruncate(outfile,os.lseek(outfile,0,1))
      success = True

      # anything I need to catch and report here?

   finally:
      if outfile: os.close(outfile)
      if tmpfile: os.close(tmpfile)

   if success:
      os.unlink(tmp)
      return 0   # Decrypted

   warning("Decryption failed for "+filename)
   if os.path.isfile(tmp):
      warning("You may need to recover from "+tmp)

   return 1	# Error reported

def sredit_encrypted(editfile):
    '''Edit an encrypted file. Only encrypted files are handled.
    Returns True if file is modified.'''
    stream = open(editfile,'rb')
    tmpfilename=get_tmpfile()
    try:
       header = Header(stream)
       sciph=cipher(header.version)

       key = get_edit_key(header.keyfinger, header.keyname)

       sciph.decrypt_stream_to_file(stream, key, tmpfilename)
       stream.close()
       stream=None
       if edit_existing_file(tmpfilename):
          # file changed
          bk=editfile+".bak"
          if os.path.isfile(bk): os.unlink(bk)
          os.rename(editfile,bk)
          stream = open(editfile,'wb')
          header.write(stream)
          sciph.encrypt_file_to_stream(tmpfilename, key, stream)
          stream.close()
          stream=None
          return True

    finally:
       # don't leak fd
       if stream: stream.close()
       # try not to leave clear file.
       if os.path.isfile(tmpfilename):
          os.unlink(tmpfilename)

    return False

def get_edit_key(finger,name):
   '''Get a key for sredit. Key will come from environment,
   global or prompt. Because sredit may be used outside of a
   git repo, we do not try and access Gitrepo.
   An exception is raised if no key is found.'''

   if debug_level:
      debug_log(2,'get_edit_key: fp: %s name: %s' % (finger,name))

   if not name:
      # There has to be some name if we want to re-encrypt
      # the file after editing.
      raise SrException("edit missing key name")

   key = srenv().get_decryption_key(finger)
   if key: return key

   key = gconf().get_decryption_key(finger)
   if key: return key

   warning("File is encrypted with key '%s' finger-print: %s" % (name,finger))
   key=getpass("key:")
   if key:
      if finger == create_keyfinger(key):
         return key
      else:
         warning("Enterred key does not match finger-print in file header.")

   raise NoKeyAvailable(name,None,finger)

#
# Config file handling.
# This is used by the Gitrepo object as well as the global
# config (object).
#
def read_config(filename):
   '''Read a config file in shlex format.
   Lines beginning with '#' are ignored.
   Return config and key dictionarys.'''
   keys=dict()
   configs=dict()
   if not os.path.isfile(filename):
      # return empty dictionarys
      return (configs,keys)

   fd=open(filename,'r')
   try:
      lex=shlex.shlex(fd)
      prev='none'
      while prev:
         next_tok=lex.get_token()
         if next_tok == '=':
            v = lex.get_token()
            if v[0] == "'": v = v[1:-1] # remove quotes
            if len(prev) > 4 and prev[:4] == 'key_':
               k = split_fields(v)
               if debug_level: debug_log(3,"keyline '%s'" % prev,k)
               # Store keys in key dictionary
               if len(k) == 1:
                  keys[k[0]] = None	# no name provided
               elif len(k) > 1:
                  keys[k[0]] = k[1]	# name provided
               if len(k) > 2:
                  warning("Key contained more than two fields.")
            else:
               # Store other values in config dictionary
               configs[prev]=v

            prev='none'
         else:
            prev=next_tok
   finally:
      fd.close()
   return (configs,keys)

def write_config(filename,configs,keys):
   '''Write config values and keys in bourne syntax.
   Existing file is renamed to {name}.bak'''
   write=filename+'.write'
   bk=filename+'.bak'

   if len(configs) == 0 and len(keys) == 0:
      if os.path.isfile(filename):
         warning("Removed config: %s" % filename)
         os.unlink(filename)
         return True

   if os.path.isfile(write):
      warning("Previous write failed.")
      os.unlink(write)

   fd=open(write,'wb')
   fd.write('#'+
      '# This file is not meant to be hand-edited.\n'+
      '# Comments and extra variables will be removed.\n'+
      '# This file should be importable by bourne/bash shell scripts.\n#\n')
   try:
      # Write config values
      for k in configs:
         fd.write("%s='%s'\n" % (k,configs[k]))
      # Write key values
      kn=0
      for k in keys:
         kn = kn + 1
         fd.write("key_%d='%s,%s'\n" % (kn,k,keys[k]))
   
   finally:
      fd.close()

   if os.path.isfile(filename):
      if os.path.isfile(bk):
         os.unlink(bk)
      os.rename(filename,bk)

   os.rename(write,filename)
   protect_file(filename)
   return True

#
# Module Inititialization
#
module_main()
if debug_level:
   import traceback

